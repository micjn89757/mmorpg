// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/game.proto

package game

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on EnterGameReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnterGameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnterGameReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnterGameReqMultiError, or
// nil if none found.
func (m *EnterGameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EnterGameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return EnterGameReqMultiError(errors)
	}

	return nil
}

// EnterGameReqMultiError is an error wrapping multiple validation errors
// returned by EnterGameReq.ValidateAll() if the designated constraints aren't met.
type EnterGameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnterGameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnterGameReqMultiError) AllErrors() []error { return m }

// EnterGameReqValidationError is the validation error returned by
// EnterGameReq.Validate if the designated constraints aren't met.
type EnterGameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnterGameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnterGameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnterGameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnterGameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnterGameReqValidationError) ErrorName() string { return "EnterGameReqValidationError" }

// Error satisfies the builtin error interface
func (e EnterGameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnterGameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnterGameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnterGameReqValidationError{}

// Validate checks the field values on EnterGameRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnterGameRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnterGameRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnterGameResMultiError, or
// nil if none found.
func (m *EnterGameRes) ValidateAll() error {
	return m.validate(true)
}

func (m *EnterGameRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnterGameResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnterGameResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnterGameResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return EnterGameResMultiError(errors)
	}

	return nil
}

// EnterGameResMultiError is an error wrapping multiple validation errors
// returned by EnterGameRes.ValidateAll() if the designated constraints aren't met.
type EnterGameResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnterGameResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnterGameResMultiError) AllErrors() []error { return m }

// EnterGameResValidationError is the validation error returned by
// EnterGameRes.Validate if the designated constraints aren't met.
type EnterGameResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnterGameResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnterGameResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnterGameResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnterGameResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnterGameResValidationError) ErrorName() string { return "EnterGameResValidationError" }

// Error satisfies the builtin error interface
func (e EnterGameResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnterGameRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnterGameResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnterGameResValidationError{}

// Validate checks the field values on EnterGameResData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnterGameResData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnterGameResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnterGameResDataMultiError, or nil if none found.
func (m *EnterGameResData) ValidateAll() error {
	return m.validate(true)
}

func (m *EnterGameResData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	if len(errors) > 0 {
		return EnterGameResDataMultiError(errors)
	}

	return nil
}

// EnterGameResDataMultiError is an error wrapping multiple validation errors
// returned by EnterGameResData.ValidateAll() if the designated constraints
// aren't met.
type EnterGameResDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnterGameResDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnterGameResDataMultiError) AllErrors() []error { return m }

// EnterGameResDataValidationError is the validation error returned by
// EnterGameResData.Validate if the designated constraints aren't met.
type EnterGameResDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnterGameResDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnterGameResDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnterGameResDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnterGameResDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnterGameResDataValidationError) ErrorName() string { return "EnterGameResDataValidationError" }

// Error satisfies the builtin error interface
func (e EnterGameResDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnterGameResData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnterGameResDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnterGameResDataValidationError{}

// Validate checks the field values on ListActorReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListActorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActorReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListActorReqMultiError, or
// nil if none found.
func (m *ListActorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListActorReqMultiError(errors)
	}

	return nil
}

// ListActorReqMultiError is an error wrapping multiple validation errors
// returned by ListActorReq.ValidateAll() if the designated constraints aren't met.
type ListActorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActorReqMultiError) AllErrors() []error { return m }

// ListActorReqValidationError is the validation error returned by
// ListActorReq.Validate if the designated constraints aren't met.
type ListActorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActorReqValidationError) ErrorName() string { return "ListActorReqValidationError" }

// Error satisfies the builtin error interface
func (e ListActorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActorReqValidationError{}

// Validate checks the field values on ListActorRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListActorRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActorRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListActorResMultiError, or
// nil if none found.
func (m *ListActorRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActorRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListActorResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListActorResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListActorResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return ListActorResMultiError(errors)
	}

	return nil
}

// ListActorResMultiError is an error wrapping multiple validation errors
// returned by ListActorRes.ValidateAll() if the designated constraints aren't met.
type ListActorResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActorResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActorResMultiError) AllErrors() []error { return m }

// ListActorResValidationError is the validation error returned by
// ListActorRes.Validate if the designated constraints aren't met.
type ListActorResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActorResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActorResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActorResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActorResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActorResValidationError) ErrorName() string { return "ListActorResValidationError" }

// Error satisfies the builtin error interface
func (e ListActorResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActorRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActorResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActorResValidationError{}

// Validate checks the field values on ListActorResData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListActorResData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActorResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActorResDataMultiError, or nil if none found.
func (m *ListActorResData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActorResData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetActors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListActorResDataValidationError{
						field:  fmt.Sprintf("Actors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListActorResDataValidationError{
						field:  fmt.Sprintf("Actors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListActorResDataValidationError{
					field:  fmt.Sprintf("Actors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListActorResDataMultiError(errors)
	}

	return nil
}

// ListActorResDataMultiError is an error wrapping multiple validation errors
// returned by ListActorResData.ValidateAll() if the designated constraints
// aren't met.
type ListActorResDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActorResDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActorResDataMultiError) AllErrors() []error { return m }

// ListActorResDataValidationError is the validation error returned by
// ListActorResData.Validate if the designated constraints aren't met.
type ListActorResDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActorResDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActorResDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActorResDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActorResDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActorResDataValidationError) ErrorName() string { return "ListActorResDataValidationError" }

// Error satisfies the builtin error interface
func (e ListActorResDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActorResData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActorResDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActorResDataValidationError{}

// Validate checks the field values on CreateActorReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateActorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateActorReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateActorReqMultiError,
// or nil if none found.
func (m *CreateActorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateActorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nickname

	if len(errors) > 0 {
		return CreateActorReqMultiError(errors)
	}

	return nil
}

// CreateActorReqMultiError is an error wrapping multiple validation errors
// returned by CreateActorReq.ValidateAll() if the designated constraints
// aren't met.
type CreateActorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateActorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateActorReqMultiError) AllErrors() []error { return m }

// CreateActorReqValidationError is the validation error returned by
// CreateActorReq.Validate if the designated constraints aren't met.
type CreateActorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateActorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateActorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateActorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateActorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateActorReqValidationError) ErrorName() string { return "CreateActorReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateActorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateActorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateActorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateActorReqValidationError{}

// Validate checks the field values on CreateActorRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateActorRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateActorRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateActorResMultiError,
// or nil if none found.
func (m *CreateActorRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateActorRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateActorResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateActorResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateActorResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return CreateActorResMultiError(errors)
	}

	return nil
}

// CreateActorResMultiError is an error wrapping multiple validation errors
// returned by CreateActorRes.ValidateAll() if the designated constraints
// aren't met.
type CreateActorResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateActorResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateActorResMultiError) AllErrors() []error { return m }

// CreateActorResValidationError is the validation error returned by
// CreateActorRes.Validate if the designated constraints aren't met.
type CreateActorResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateActorResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateActorResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateActorResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateActorResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateActorResValidationError) ErrorName() string { return "CreateActorResValidationError" }

// Error satisfies the builtin error interface
func (e CreateActorResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateActorRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateActorResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateActorResValidationError{}

// Validate checks the field values on CreateActorResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateActorResData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateActorResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateActorResDataMultiError, or nil if none found.
func (m *CreateActorResData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateActorResData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateActorResDataMultiError(errors)
	}

	return nil
}

// CreateActorResDataMultiError is an error wrapping multiple validation errors
// returned by CreateActorResData.ValidateAll() if the designated constraints
// aren't met.
type CreateActorResDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateActorResDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateActorResDataMultiError) AllErrors() []error { return m }

// CreateActorResDataValidationError is the validation error returned by
// CreateActorResData.Validate if the designated constraints aren't met.
type CreateActorResDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateActorResDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateActorResDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateActorResDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateActorResDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateActorResDataValidationError) ErrorName() string {
	return "CreateActorResDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateActorResDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateActorResData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateActorResDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateActorResDataValidationError{}

// Validate checks the field values on EnterSceneReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnterSceneReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnterSceneReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnterSceneReqMultiError, or
// nil if none found.
func (m *EnterSceneReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EnterSceneReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActorId

	if len(errors) > 0 {
		return EnterSceneReqMultiError(errors)
	}

	return nil
}

// EnterSceneReqMultiError is an error wrapping multiple validation errors
// returned by EnterSceneReq.ValidateAll() if the designated constraints
// aren't met.
type EnterSceneReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnterSceneReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnterSceneReqMultiError) AllErrors() []error { return m }

// EnterSceneReqValidationError is the validation error returned by
// EnterSceneReq.Validate if the designated constraints aren't met.
type EnterSceneReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnterSceneReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnterSceneReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnterSceneReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnterSceneReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnterSceneReqValidationError) ErrorName() string { return "EnterSceneReqValidationError" }

// Error satisfies the builtin error interface
func (e EnterSceneReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnterSceneReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnterSceneReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnterSceneReqValidationError{}

// Validate checks the field values on EnterSceneRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnterSceneRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnterSceneRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnterSceneResMultiError, or
// nil if none found.
func (m *EnterSceneRes) ValidateAll() error {
	return m.validate(true)
}

func (m *EnterSceneRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnterSceneResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnterSceneResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnterSceneResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return EnterSceneResMultiError(errors)
	}

	return nil
}

// EnterSceneResMultiError is an error wrapping multiple validation errors
// returned by EnterSceneRes.ValidateAll() if the designated constraints
// aren't met.
type EnterSceneResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnterSceneResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnterSceneResMultiError) AllErrors() []error { return m }

// EnterSceneResValidationError is the validation error returned by
// EnterSceneRes.Validate if the designated constraints aren't met.
type EnterSceneResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnterSceneResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnterSceneResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnterSceneResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnterSceneResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnterSceneResValidationError) ErrorName() string { return "EnterSceneResValidationError" }

// Error satisfies the builtin error interface
func (e EnterSceneResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnterSceneRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnterSceneResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnterSceneResValidationError{}

// Validate checks the field values on EnterSceneResData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnterSceneResData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnterSceneResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnterSceneResDataMultiError, or nil if none found.
func (m *EnterSceneResData) ValidateAll() error {
	return m.validate(true)
}

func (m *EnterSceneResData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SceneId

	if len(errors) > 0 {
		return EnterSceneResDataMultiError(errors)
	}

	return nil
}

// EnterSceneResDataMultiError is an error wrapping multiple validation errors
// returned by EnterSceneResData.ValidateAll() if the designated constraints
// aren't met.
type EnterSceneResDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnterSceneResDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnterSceneResDataMultiError) AllErrors() []error { return m }

// EnterSceneResDataValidationError is the validation error returned by
// EnterSceneResData.Validate if the designated constraints aren't met.
type EnterSceneResDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnterSceneResDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnterSceneResDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnterSceneResDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnterSceneResDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnterSceneResDataValidationError) ErrorName() string {
	return "EnterSceneResDataValidationError"
}

// Error satisfies the builtin error interface
func (e EnterSceneResDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnterSceneResData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnterSceneResDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnterSceneResDataValidationError{}

// Validate checks the field values on ChangeSceneReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChangeSceneReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSceneReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChangeSceneReqMultiError,
// or nil if none found.
func (m *ChangeSceneReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSceneReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SceneId

	if len(errors) > 0 {
		return ChangeSceneReqMultiError(errors)
	}

	return nil
}

// ChangeSceneReqMultiError is an error wrapping multiple validation errors
// returned by ChangeSceneReq.ValidateAll() if the designated constraints
// aren't met.
type ChangeSceneReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSceneReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSceneReqMultiError) AllErrors() []error { return m }

// ChangeSceneReqValidationError is the validation error returned by
// ChangeSceneReq.Validate if the designated constraints aren't met.
type ChangeSceneReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSceneReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSceneReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSceneReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSceneReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSceneReqValidationError) ErrorName() string { return "ChangeSceneReqValidationError" }

// Error satisfies the builtin error interface
func (e ChangeSceneReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSceneReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSceneReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSceneReqValidationError{}

// Validate checks the field values on ChangeSceneRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChangeSceneRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSceneRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChangeSceneResMultiError,
// or nil if none found.
func (m *ChangeSceneRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSceneRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSceneResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSceneResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSceneResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return ChangeSceneResMultiError(errors)
	}

	return nil
}

// ChangeSceneResMultiError is an error wrapping multiple validation errors
// returned by ChangeSceneRes.ValidateAll() if the designated constraints
// aren't met.
type ChangeSceneResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSceneResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSceneResMultiError) AllErrors() []error { return m }

// ChangeSceneResValidationError is the validation error returned by
// ChangeSceneRes.Validate if the designated constraints aren't met.
type ChangeSceneResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSceneResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSceneResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSceneResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSceneResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSceneResValidationError) ErrorName() string { return "ChangeSceneResValidationError" }

// Error satisfies the builtin error interface
func (e ChangeSceneResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSceneRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSceneResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSceneResValidationError{}

// Validate checks the field values on ChangeSceneResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeSceneResData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSceneResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeSceneResDataMultiError, or nil if none found.
func (m *ChangeSceneResData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSceneResData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ChangeSceneResDataMultiError(errors)
	}

	return nil
}

// ChangeSceneResDataMultiError is an error wrapping multiple validation errors
// returned by ChangeSceneResData.ValidateAll() if the designated constraints
// aren't met.
type ChangeSceneResDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSceneResDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSceneResDataMultiError) AllErrors() []error { return m }

// ChangeSceneResDataValidationError is the validation error returned by
// ChangeSceneResData.Validate if the designated constraints aren't met.
type ChangeSceneResDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSceneResDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSceneResDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSceneResDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSceneResDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSceneResDataValidationError) ErrorName() string {
	return "ChangeSceneResDataValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeSceneResDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSceneResData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSceneResDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSceneResDataValidationError{}

// Validate checks the field values on CreateReplicationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReplicationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplicationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateReplicationReqMultiError, or nil if none found.
func (m *CreateReplicationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplicationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplicationType

	if len(errors) > 0 {
		return CreateReplicationReqMultiError(errors)
	}

	return nil
}

// CreateReplicationReqMultiError is an error wrapping multiple validation
// errors returned by CreateReplicationReq.ValidateAll() if the designated
// constraints aren't met.
type CreateReplicationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplicationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplicationReqMultiError) AllErrors() []error { return m }

// CreateReplicationReqValidationError is the validation error returned by
// CreateReplicationReq.Validate if the designated constraints aren't met.
type CreateReplicationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplicationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplicationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplicationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplicationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplicationReqValidationError) ErrorName() string {
	return "CreateReplicationReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReplicationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplicationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplicationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplicationReqValidationError{}

// Validate checks the field values on CreateReplicationRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReplicationRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplicationRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateReplicationResMultiError, or nil if none found.
func (m *CreateReplicationRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplicationRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateReplicationResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateReplicationResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateReplicationResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return CreateReplicationResMultiError(errors)
	}

	return nil
}

// CreateReplicationResMultiError is an error wrapping multiple validation
// errors returned by CreateReplicationRes.ValidateAll() if the designated
// constraints aren't met.
type CreateReplicationResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplicationResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplicationResMultiError) AllErrors() []error { return m }

// CreateReplicationResValidationError is the validation error returned by
// CreateReplicationRes.Validate if the designated constraints aren't met.
type CreateReplicationResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplicationResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplicationResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplicationResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplicationResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplicationResValidationError) ErrorName() string {
	return "CreateReplicationResValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReplicationResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplicationRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplicationResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplicationResValidationError{}

// Validate checks the field values on CreateReplicationResData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReplicationResData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplicationResData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateReplicationResDataMultiError, or nil if none found.
func (m *CreateReplicationResData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplicationResData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateReplicationResDataMultiError(errors)
	}

	return nil
}

// CreateReplicationResDataMultiError is an error wrapping multiple validation
// errors returned by CreateReplicationResData.ValidateAll() if the designated
// constraints aren't met.
type CreateReplicationResDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplicationResDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplicationResDataMultiError) AllErrors() []error { return m }

// CreateReplicationResDataValidationError is the validation error returned by
// CreateReplicationResData.Validate if the designated constraints aren't met.
type CreateReplicationResDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplicationResDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplicationResDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplicationResDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplicationResDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplicationResDataValidationError) ErrorName() string {
	return "CreateReplicationResDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReplicationResDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplicationResData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplicationResDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplicationResDataValidationError{}

// Validate checks the field values on LeaveReplicationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaveReplicationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveReplicationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaveReplicationReqMultiError, or nil if none found.
func (m *LeaveReplicationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveReplicationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LeaveReplicationReqMultiError(errors)
	}

	return nil
}

// LeaveReplicationReqMultiError is an error wrapping multiple validation
// errors returned by LeaveReplicationReq.ValidateAll() if the designated
// constraints aren't met.
type LeaveReplicationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveReplicationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveReplicationReqMultiError) AllErrors() []error { return m }

// LeaveReplicationReqValidationError is the validation error returned by
// LeaveReplicationReq.Validate if the designated constraints aren't met.
type LeaveReplicationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveReplicationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveReplicationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveReplicationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveReplicationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveReplicationReqValidationError) ErrorName() string {
	return "LeaveReplicationReqValidationError"
}

// Error satisfies the builtin error interface
func (e LeaveReplicationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveReplicationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveReplicationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveReplicationReqValidationError{}

// Validate checks the field values on LeaveReplicationRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaveReplicationRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveReplicationRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaveReplicationResMultiError, or nil if none found.
func (m *LeaveReplicationRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveReplicationRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveReplicationResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveReplicationResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveReplicationResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if len(errors) > 0 {
		return LeaveReplicationResMultiError(errors)
	}

	return nil
}

// LeaveReplicationResMultiError is an error wrapping multiple validation
// errors returned by LeaveReplicationRes.ValidateAll() if the designated
// constraints aren't met.
type LeaveReplicationResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveReplicationResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveReplicationResMultiError) AllErrors() []error { return m }

// LeaveReplicationResValidationError is the validation error returned by
// LeaveReplicationRes.Validate if the designated constraints aren't met.
type LeaveReplicationResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveReplicationResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveReplicationResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveReplicationResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveReplicationResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveReplicationResValidationError) ErrorName() string {
	return "LeaveReplicationResValidationError"
}

// Error satisfies the builtin error interface
func (e LeaveReplicationResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveReplicationRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveReplicationResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveReplicationResValidationError{}

// Validate checks the field values on LeaveReplicationReqData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaveReplicationReqData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveReplicationReqData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaveReplicationReqDataMultiError, or nil if none found.
func (m *LeaveReplicationReqData) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveReplicationReqData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SceneId

	if len(errors) > 0 {
		return LeaveReplicationReqDataMultiError(errors)
	}

	return nil
}

// LeaveReplicationReqDataMultiError is an error wrapping multiple validation
// errors returned by LeaveReplicationReqData.ValidateAll() if the designated
// constraints aren't met.
type LeaveReplicationReqDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveReplicationReqDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveReplicationReqDataMultiError) AllErrors() []error { return m }

// LeaveReplicationReqDataValidationError is the validation error returned by
// LeaveReplicationReqData.Validate if the designated constraints aren't met.
type LeaveReplicationReqDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveReplicationReqDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveReplicationReqDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveReplicationReqDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveReplicationReqDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveReplicationReqDataValidationError) ErrorName() string {
	return "LeaveReplicationReqDataValidationError"
}

// Error satisfies the builtin error interface
func (e LeaveReplicationReqDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveReplicationReqData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveReplicationReqDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveReplicationReqDataValidationError{}

// Validate checks the field values on IActor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IActor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IActor with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IActorMultiError, or nil if none found.
func (m *IActor) ValidateAll() error {
	return m.validate(true)
}

func (m *IActor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Nickname

	// no validation rules for PosX

	// no validation rules for PosY

	// no validation rules for Type

	// no validation rules for Account

	// no validation rules for SceneId

	if len(errors) > 0 {
		return IActorMultiError(errors)
	}

	return nil
}

// IActorMultiError is an error wrapping multiple validation errors returned by
// IActor.ValidateAll() if the designated constraints aren't met.
type IActorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IActorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IActorMultiError) AllErrors() []error { return m }

// IActorValidationError is the validation error returned by IActor.Validate if
// the designated constraints aren't met.
type IActorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IActorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IActorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IActorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IActorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IActorValidationError) ErrorName() string { return "IActorValidationError" }

// Error satisfies the builtin error interface
func (e IActorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIActor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IActorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IActorValidationError{}

// Validate checks the field values on InputFromClient with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InputFromClient) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InputFromClient with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InputFromClientMultiError, or nil if none found.
func (m *InputFromClient) ValidateAll() error {
	return m.validate(true)
}

func (m *InputFromClient) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DirectionX

	// no validation rules for DirectionY

	// no validation rules for Dt

	if len(errors) > 0 {
		return InputFromClientMultiError(errors)
	}

	return nil
}

// InputFromClientMultiError is an error wrapping multiple validation errors
// returned by InputFromClient.ValidateAll() if the designated constraints
// aren't met.
type InputFromClientMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InputFromClientMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InputFromClientMultiError) AllErrors() []error { return m }

// InputFromClientValidationError is the validation error returned by
// InputFromClient.Validate if the designated constraints aren't met.
type InputFromClientValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InputFromClientValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InputFromClientValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InputFromClientValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InputFromClientValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InputFromClientValidationError) ErrorName() string { return "InputFromClientValidationError" }

// Error satisfies the builtin error interface
func (e InputFromClientValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInputFromClient.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InputFromClientValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InputFromClientValidationError{}

// Validate checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *State) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StateMultiError, or nil if none found.
func (m *State) ValidateAll() error {
	return m.validate(true)
}

func (m *State) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetActors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  fmt.Sprintf("Actors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  fmt.Sprintf("Actors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  fmt.Sprintf("Actors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StateMultiError(errors)
	}

	return nil
}

// StateMultiError is an error wrapping multiple validation errors returned by
// State.ValidateAll() if the designated constraints aren't met.
type StateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateMultiError) AllErrors() []error { return m }

// StateValidationError is the validation error returned by State.Validate if
// the designated constraints aren't met.
type StateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateValidationError) ErrorName() string { return "StateValidationError" }

// Error satisfies the builtin error interface
func (e StateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateValidationError{}

// Validate checks the field values on StateFromServer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StateFromServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StateFromServer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StateFromServerMultiError, or nil if none found.
func (m *StateFromServer) ValidateAll() error {
	return m.validate(true)
}

func (m *StateFromServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StateFromServerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StateFromServerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StateFromServerValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateFromServerValidationError{
						field:  fmt.Sprintf("Input[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateFromServerValidationError{
						field:  fmt.Sprintf("Input[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateFromServerValidationError{
					field:  fmt.Sprintf("Input[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StateFromServerMultiError(errors)
	}

	return nil
}

// StateFromServerMultiError is an error wrapping multiple validation errors
// returned by StateFromServer.ValidateAll() if the designated constraints
// aren't met.
type StateFromServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateFromServerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateFromServerMultiError) AllErrors() []error { return m }

// StateFromServerValidationError is the validation error returned by
// StateFromServer.Validate if the designated constraints aren't met.
type StateFromServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateFromServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateFromServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateFromServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateFromServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateFromServerValidationError) ErrorName() string { return "StateFromServerValidationError" }

// Error satisfies the builtin error interface
func (e StateFromServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStateFromServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateFromServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateFromServerValidationError{}
